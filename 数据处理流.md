##### 百度平面坐标系
![百度地图平面坐标](https://camo.githubusercontent.com/bd6a836092ac2463090236c0dc177b947a9f6437/68747470733a2f2f7261772e6769746875622e636f6d2f696c696665352f6c6966652f6d61737465722f737461746963732f696d616765732f6261696475506978656c436f6f7264696e617465732e706e67)  
百度地图整个平面坐标系，地图缩放级别为18，此时1像素距离对应坐标1刻度。
![可视区域坐标](https://note.youdao.com/yws/public/resource/6b5054265572a94b7cb65cbeaa2a440a/xmlnote/WEBRESOURCEaf7f8dcbeafc9c91be0cef00e95ba925/4975)
百度地图的像素坐标，对应元素css属性left和top

##### 传入的数据格式
```
[{
    location: {
        lng: 10.21,
        lat: 50.45
    },
    //其他自定义属性
}]
```
##### 百度地图自定义overlay
```
class Marker extends window.BMap.Overlay {
    constructor () {
        //自定义方法
    }
    initialize () {
        // 生成dom对象
        var div = document.createElement("div");
        // 插入对应容器，地图有5个容器，不同的容器z-index不一样
        map.getPanes().labelPane.appendChild(div)
        //返回dom对象
        return div
    },
    draw () {
        // 根据经纬度坐标转换为像素坐标，并设置给容器    
        var position = this._map.pointToOverlayPixel(this._center)
        this._div.style.left = position.x - this._length / 2 + "px"
        this._div.style.top = position.y - this._length / 2 + "px" 
    }
}
```
##### 基本配置
详细使用说明，可看readme.md
```
{
  marker: {
    icon: icon,
    offsetX: -15,
    offsetY: -15,
    width: 30,
    height: 30,
    methods: {
      click (data, marker) {
      }
    },
  },
  infoWindow: {
    el: infoWindow,
    fetch: () => {
      return Promise.resolve({address: '幻想乡'})
    }
  },
  cluster: {
    marker: {
      icon:clusterIcon, //url路径
      offsetX: -16,
      offsetY: -16,
      textStyle: {
        fontSize: '12px',
        color: 'red',
        left: '18px',
        top: '15px',
        // transform: 'translate(10px, 10px)'
      },
      methods: {
        click(data) {
        }
      },
    },
    gridSize: 60,
    minClusterSize: 3,
    maxZoom: 18,
  }
}
```
##### 1、进行球面坐标转化为平面坐标
```
// 将经纬度坐标转换为墨托卡坐标,data为数据集合或单个
  transferToMercator (data) {
    var projection = this.map.getMapType().getProjection()
    if (data instanceof Array) {
      data.forEach((item) => {
        let pixel = projection.lngLatToPoint(item.location)
        item.coordinates_mercator = [Math.round(pixel.x), Math.round(pixel.y)]
      })
    } else {
      let pixel = projection.lngLatToPoint(data.location)
      data.coordinates_mercator = [Math.round(pixel.x), Math.round(pixel.y)]
    }
    return data
  }
 
 //输出的数据格式
 [{
     location: {
        lng: 10.21,
        lat: 50.45
     },
     coordinates_mercator: [1000000.100, 50.1000] 
 }]
```
##### 2、过滤非可视区域内的点
![可视区域坐标](https://note.youdao.com/yws/public/resource/6b5054265572a94b7cb65cbeaa2a440a/xmlnote/WEBRESOURCEaf7f8dcbeafc9c91be0cef00e95ba925/4975)

```
//获取可视区域，平面坐标系下的坐标
let zoomUnit = Math.pow(2, 18 - map.getZoom())
let projection = map.getMapType().getProjection()
let mcCenter = projection.lngLatToPoint(map.getCenter())
let mapSize = map.getSize()
let nwMc = new window.BMap.Pixel(mcCenter.x - mapSize.width / 2 * zoomUnit, mcCenter.y + mapSize.height / 2 * zoomUnit) // 左上角墨卡托
let seMc = new window.BMap.Pixel(mcCenter.x + mapSize.width / 2 * zoomUnit, mcCenter.y - mapSize.height / 2 * zoomUnit) // 右下角墨卡托
clusterOptions.gridSize_mercator = clusterOptions.gridSize * zoomUnit // gridSize转换到墨卡托坐标上的大小

// 判断是否在可视区域内，实质就是判断点是否在正方形内，代码就不贴了

```

##### 3、对所有点进行聚合
```
// 聚合类，表示每一个聚合方块块
// 记录聚合块的中心位置，以及里面聚合了哪些点
class Cluster {
  markers = []
  constructor (MarkerCluster, data) {
    this.MarkerCluster = MarkerCluster
    this.clusterOptions = MarkerCluster.options.cluster
    this.center = data.coordinates_mercator
    this.markers.push(data)
  }
  // 返回聚合的中心点平面坐标，格式为[x,y]
  getMarkers () {
    return this.markers
  }
  // 点是否在聚合范围内，point为墨卡托坐标
  isPointInCluster (coordinates) {
    let gridSize = this.clusterOptions.gridSize_mercator
    let center = this.center
    let result = coordinates[0] >= center[0] - gridSize &&
    coordinates[0] <= center[0] + gridSize &&
    coordinates[1] <= center[1] + gridSize &&
    coordinates[1] >= center[1] - gridSize
    return result
  }
  addMarker (markerData) {
    this.markers.push(markerData)
    // 若isAverageCenter，设为true, 则会不断更新中心点center位置，取质心
    if (this.clusterOptions.isAverageCenter) {
      let n = this.markers.length
      let ox = this.center[0]
      let oy = this.center[1]
      let x1 = markerData.coordinates_mercator[0]
      let y1 = markerData.coordinates_mercator[1]
      this.center = [(ox * (n - 1) + x1)/n, (oy * (n - 1) + y1)/n]
    }
  }
}

// 计算其中一个点，是否需要加入到其他聚合方块内，若没有，则以此点新建聚合方块
_addToCluster (data) {
    let clusterToAddTo = null
    let distance
    let ponit = data.coordinates_mercator
    this.clusters.forEach(cluster => {
      if(cluster.isPointInCluster(ponit)) { // 1、是否在聚合方块内
        let center = cluster.getCenter() // 获取聚合中心的墨卡托坐标
        // 计算点与聚合中心的距离, 取最近的一个聚合类
        let d = Math.pow(ponit[0] - center[0], 2) + Math.pow(ponit[1] - center[1], 2)
        // let d = Math.abs(ponit[0] - center[0])*Math.ceil(Math.sqrt(1 + Math.pow((ponit[1] - center[1])/(ponit[0] - center[0]), 2)))
        // 2、若在多个聚合方块内，则取最近的一个
        if (distance === undefined || d < distance) {
          distance = d
          clusterToAddTo = cluster
        }
      }
    })

    if (clusterToAddTo) {
      clusterToAddTo.addMarker(data)
      clusterToAddTo = null
      distance = undefined
    } else {
    // 3、若不在聚合方块内，则以此点位中心，新建一个
      this.clusters.push(new Cluster(this, data))
      clusterToAddTo = null
      distance = undefined
    }
  }
  
  //最后得到输出
  clusters: [Cluster,Cluster,Cluster.....]
  
```
##### 4、根据计算结果渲染

使用百度地图自定义overlay在展示数据
```
draw () {
    let markers = []
    let options = this.options
    let clusterOptions = this.options.cluster
    // 若超出设定的放大级别，则不会聚合
    if (!clusterOptions || this.map.getZoom() > clusterOptions.maxZoom) {
      this.data.forEach(item => {
        let marker = this._createMarker(item, options)
        markers.push(marker)
      })
    } else {
      this.clusters.forEach((cluster) => {
       // 若聚合方块内的点小于设定的最小数目，则也不会聚合
        if (cluster.markers.length >= clusterOptions.minClusterSize) {
          let clusterMarker = this._createMarker(cluster, clusterOptions)
          markers.push(clusterMarker)
        } else {
          cluster.markers.forEach(data => {
            let marker = this._createMarker(data, options)
            markers.push(marker)
          })
        }
      })
    }
    markers.forEach((marker) => {
      this.map.addOverlay(marker)
    })
    this.markers = markers
  }
// 得到输出
 markers: [Marker,Marker,Marker,Marker...]
```


